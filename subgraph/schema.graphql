interface Event {
  id: ID!
  timestamp: BigInt!
  blockNumber: BigInt!
  transactionHash: String!
  user: User!
  wave: Wave # Optional in interface
}

type DepositEvent @entity {
  id: ID!
  timestamp: BigInt!
  blockNumber: BigInt!
  transactionHash: String!
  user: User!
  wave: Wave # Must match interface exactly
  # Additional fields specific to DepositEvent
  amount: BigInt!
  from: String!
  to: String!
}

type WithdrawEvent @entity {
  id: ID!
  timestamp: BigInt!
  blockNumber: BigInt!
  transactionHash: String!
  user: User!
  wave: Wave
  # Additional fields specific to WithdrawEvent
  amount: BigInt!
  from: String!
  to: String!
}

type RewardEvent @entity {
  id: ID!
  timestamp: BigInt!
  blockNumber: BigInt!
  transactionHash: String!
  user: User!
  wave: Wave
  # Additional fields specific to RewardEvent
  amount: BigInt!
  odds: String!
}

type ReferralEvent @entity {
  id: ID!
  timestamp: BigInt!
  blockNumber: BigInt!
  transactionHash: String!
  user: User!
  wave: Wave
  # Additional fields specific to ReferralEvent
  referredUser: User!
}

type WaveStartEvent @entity {
  id: ID!
  timestamp: BigInt!
  blockNumber: BigInt!
  transactionHash: String!
  user: User!
  wave: Wave
  # Additional fields specific to WaveStartEvent
  totalStake: BigInt!
}

type WaveEndEvent @entity {
  id: ID!
  timestamp: BigInt!
  blockNumber: BigInt!
  transactionHash: String!
  user: User!
  wave: Wave
  # Additional fields specific to WaveEndEvent
  totalRewards: BigInt!
  totalParticipants: Int!
}

# Rest of your schema remains the same
type ProtocolMetrics @entity {
  id: ID!
  totalStaked: BigInt!
  totalRewardsGiven: BigInt!
  totalUsers: Int!
}

type User @entity {
  id: ID!
  totalStake: BigInt!
  totalReward: BigInt!
  stakes: [Stake!] @derivedFrom(field: "user")
  withdraws: [Withdraw!] @derivedFrom(field: "user")
  winners: [Winner!] @derivedFrom(field: "user")
  referredUsers: [User!] @derivedFrom(field: "referrer")
  referrer: User
  createdAt: BigInt!
  lastActionAt: BigInt!
  depositEvents: [DepositEvent!] @derivedFrom(field: "user")
  withdrawEvents: [WithdrawEvent!] @derivedFrom(field: "user")
  rewardEvents: [RewardEvent!] @derivedFrom(field: "user")
  referralEvents: [ReferralEvent!] @derivedFrom(field: "user")
}

type Stake @entity {
  id: ID!
  user: User!
  amount: BigInt!
  wave: Wave!
  timestamp: BigInt!
  blockNumber: BigInt!
  transactionHash: String!
}

type Withdraw @entity {
  id: ID!
  user: User!
  amount: BigInt!
  wave: Wave!
  timestamp: BigInt!
  blockNumber: BigInt!
  transactionHash: String!
}

type Wave @entity {
  id: ID!
  totalStake: BigInt!
  totalReward: BigInt!
  randomSeed: BigInt
  rewardsDistributed: Boolean!
  stakes: [Stake!]! @derivedFrom(field: "wave")
  withdraws: [Withdraw!]! @derivedFrom(field: "wave")
  winners: [Winner!]! @derivedFrom(field: "wave")
  startedAt: BigInt!
  endedAt: BigInt
  blockNumber: BigInt!
  depositEvents: [DepositEvent!] @derivedFrom(field: "wave")
  withdrawEvents: [WithdrawEvent!] @derivedFrom(field: "wave")
  rewardEvents: [RewardEvent!] @derivedFrom(field: "wave")
  startEvent: WaveStartEvent @derivedFrom(field: "wave")
  endEvent: WaveEndEvent @derivedFrom(field: "wave")
}

type Winner @entity {
  id: ID!
  user: User!
  wave: Wave!
  reward: BigInt!
  odds: String!
  timestamp: BigInt!
  blockNumber: BigInt!
  transactionHash: String!
}